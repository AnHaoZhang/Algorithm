
辨析1.递归与迭代
### 递归：
  #### 定义
   递归是一种通过函数调用自身来解决问题的方法。通常，递归问题包含一个或多个基例，以及通过将问题分解为更小的子问题来解决问题的方式。 及由大到小，不断的从大问题分解成一个个小问题，最终收集所有的解
#### 优点：
代码简洁：递归代码通常更简洁、更易读，特别是解决树结构、图结构和分治法问题时。
逻辑清晰：递归方法直接反映问题的分解过程，有助于理解和证明算法的正确性。
#### 缺点：
效率低下：递归调用会产生大量的函数调用开销，可能导致较大的时间和空间复杂度。
堆栈溢出：递归深度过大时，可能导致堆栈溢出错误。
### 迭代：
#### 定义
   迭代是一种通过重复循环结构来解决问题的方法。通过逐步逼近问题的解，迭代方法避免了函数调用的开销。从小到大，有一个个小问题的子集，最终解决大问题; 有结束条件。

#### 优点：
效率较高：迭代避免了递归的函数调用开销，通常在时间和空间上更加高效。
无堆栈溢出：迭代方法使用循环，不会产生堆栈溢出问题。
#### 缺点：
代码复杂：对于某些问题（如树、图），迭代代码可能比递归代码更加复杂和难以理解。
可读性差：迭代实现有时不如递归实现直观，尤其是问题本身具有递归性质时。
递归与迭代对比

| 特性       | 递归                                   | 迭代                                      |
| ---------- | -------------------------------------- | ----------------------------------------- |
| 定义       | 函数调用自身                           | 使用循环结构                              |
| 代码复杂度 | 通常较简洁                             | 通常较复杂                                |
| 效率       | 较低（函数调用开销）                   | 较高（无函数调用开销）                    |
| 可读性     | 高（直接反映问题分解过程）             | 低（特别是复杂结构时）                    |
| 堆栈使用   | 可能导致堆栈溢出                       | 不会导致堆栈溢出                          |
| 适用场景   | 适合处理具有递归性质的问题，如树、图等 | 适合处理简单的循环问题和避免递归深度过大的问题 |
|结束条件|	必须有基例或结束条件来终止递归调用|	必须有终止条件来结束循环|
|实现方式|	在递归函数内部通过条件判断|	在循环结构中通过条件判断|
|终止效果|	防止递归无限进行，避免堆栈溢出|	防止循环无限进行，避免死循环|
#### 自上而下（Top-Down）
##### 定义：自上而下的方法从问题的顶层开始，将问题分解为子问题，递归地解决每个子问题，直到达到最基本的子问题，然后合并这些子问题的解以得到原问题的解。
##### 特点：
递归：通常使用递归实现。
子问题分解：不断将问题分解为更小的子问题。
备忘录（记忆化）：为提高效率，可以使用备忘录（memoization）技术，记录已经解决的子问题的结果，避免重复计算。
爬楼梯问题的自上而下实现（递归 + 备忘录）：

~~~
java
复制代码
public int climbingStairsTopDown(int n) {
int[] memo = new int[n + 1];
Arrays.fill(memo, -1);
return climb(n, memo);
}

private int climb(int n, int[] memo) {
if (n <= 1) {
return 1;
}
if (memo[n] != -1) {
return memo[n];
}
memo[n] = climb(n - 1, memo) + climb(n - 2, memo);
return memo[n];
}
~~~
在这个实现中，我们从问题的顶层（n 阶楼梯）开始，递归地解决每个子问题（n-1 和 n-2 阶楼梯），直到达到最基本的子问题（0 或 1 阶楼梯）。

#### 自下而上（Bottom-Up）
##### 定义：自下而上的方法从问题的最基本子问题开始，逐步解决更大规模的问题，直到解决原问题。
##### 特点：
迭代：通常使用迭代实现。
状态转移：通过状态转移方程逐步计算出更大规模问题的解。
动态规划：常用于动态规划问题，构建一个表格来记录子问题的解。
爬楼梯问题的自下而上实现（迭代 + 动态规划）：
~~~
java
复制代码
public int climbingStairsBottomUp(int n) {
if (n <= 1) {
return 1;
}
int[] dp = new int[n + 1];
dp[0] = 1;
dp[1] = 1;
for (int i = 2; i <= n; i++) {
dp[i] = dp[i - 1] + dp[i - 2];
}
return dp[n];
}
~~~
在这个实现中，我们从最基本的子问题（0 和 1 阶楼梯）开始，逐步计算出每个规模更大的子问题的解，直到计算出原问题（n 阶楼梯）的解。

#### 对比
自上而下：从问题的顶层开始，递归地解决子问题，通常使用递归实现，可能会导致重复计算子问题，效率较低，但代码简洁直观。使用备忘录（memoization）技术可以提高效率。
自下而上：从最基本的子问题开始，迭代地解决更大规模的问题，通常使用迭代实现，避免了重复计算，效率较高，但代码可能相对复杂。
#### 总结
在爬楼梯问题中：
递归实现：通常是自上而下的方法，尤其是当使用备忘录优化时（递归 + 备忘录）。
迭代实现：通常是自下而上的方法，通过动态规划逐步解决子问题。
### 动态规划
#### 简介
动态规划（Dynamic Programming, DP）是一种用于解决具有重叠子问题和最优子结构性质的问题的算法设计方法。
动态规划通过将问题分解为子问题，并将子问题的解存储以避免重复计算，从而提高效率。
动态规划有两种常见的实现方式：自上而下的递归（通常结合备忘录）和自下而上的迭代（通常使用表格）。
##### 动态规划的基本思想
重叠子问题：问题可以分解为相同子问题的重复计算。
最优子结构：问题的最优解包含其子问题的最优解。
1. 两种实现方式
自上而下（Top-Down）：递归加上备忘录（记忆化）。
自下而上（Bottom-Up）：迭代加上表格（数组）。
爬楼梯问题的动态规划实现
假设你要爬 n 阶楼梯，每次可以爬 1 阶或 2 阶，有多少种不同的方法可以爬到楼顶？

自上而下（递归 + 备忘录）
这种方法从顶层开始解决问题，并在解决过程中记录已经计算过的子问题的结果，避免重复计算。
~~~
public int climbStairsTopDown(int n) {
int[] memo = new int[n + 1];
Arrays.fill(memo, -1);
return climb(n, memo);
}

private int climb(int n, int[] memo) {
if (n <= 1) {
return 1;
}
if (memo[n] != -1) {
return memo[n];
}
memo[n] = climb(n - 1, memo) + climb(n - 2, memo);
return memo[n];
}
~~~
自下而上（迭代 + 动态规划）
这种方法从底层开始逐步构建解决方案，通常使用一个数组来记录每个子问题的解。
~~~
public int climbStairsBottomUp(int n) {
if (n <= 1) {
return 1;
}
int[] dp = new int[n + 1];
dp[0] = 1;
dp[1] = 1;
for (int i = 2; i <= n; i++) {
dp[i] = dp[i - 1] + dp[i - 2];
}
return dp[n];
}
~~~
对比表格
以下是自上而下和自下而上两种动态规划方法的对比：

| 特性       | 自上而下（Top-Down）                 | 自下而上（Bottom-Up）                      |
| ---------- | ------------------------------------ | ----------------------------------------- |
| 定义       | 递归 + 备忘录                         | 迭代 + 动态规划表格                        |
| 代码复杂度 | 通常较简洁                           | 通常较复杂                                 |
| 效率       | 较高，避免了重复计算                  | 较高，通过迭代高效计算                     |
| 可读性     | 高（直接反映问题分解过程）            | 低（特别是复杂结构时）                      |
| 空间使用   | 可能使用较多的栈空间                   | 仅使用表格空间                             |
| 适用场景   | 适合处理具有递归性质的问题，如树、图等 | 适合处理简单的循环问题和避免递归深度过大的问题 |

#### 动态规划的优势
高效：通过存储子问题的解，避免重复计算，大大提高了效率。
通用：适用于许多最优化问题，如最长子序列、背包问题、最短路径等。

总结
动态规划是一种强大的算法设计方法，适用于解决重叠子问题和最优子结构的问题。通过自上而下的递归结合备忘录，或自下而上的迭代结合动态规划表格，可以有效地提高算法的效率。

#### 动态规划问题解题步骤
1. 定义子问题：
    明确如何将原问题分解为更小的子问题。通常，这一步包括找出状态和状态转移关系。
2. 推导状态转移方程：
    确定如何通过已解决的子问题来解决当前子问题。即找出状态转移方程。
3. 确定初始条件和边界条件：
    找出最小子问题的解，并确保这些解可以作为基础，逐步构建出更大规模问题的解。
4. 计算顺序：
    决定计算子问题的顺序，通常是从最小子问题开始逐步解决，直至解决原问题。
5. 优化空间复杂度（可选）：
    根据问题的特性，考虑是否可以使用滚动数组或其他方法优化空间复杂度。

#### 具体示例：爬楼梯问题

假设你要爬 `n` 阶楼梯，每次可以爬 1 阶或 2 阶，有多少种不同的方法可以爬到楼顶？

##### 1. 定义子问题

设 `dp[i]` 表示到达第 `i` 阶的方法数。

##### 2. 推导状态转移方程

可以通过如下方式到达第 `i` 阶：
- 从第 `i-1` 阶爬 1 阶到达第 `i` 阶。
- 从第 `i-2` 阶爬 2 阶到达第 `i` 阶。

因此，状态转移方程为：
\[ dp[i] = dp[i-1] + dp[i-2] \]

##### 3. 确定初始条件和边界条件

- 当 `i=0` 时，只有一种方法（站在地面上，不动）。
- 当 `i=1` 时，只有一种方法（从第 0 阶爬 1 阶到达第 1 阶）。

因此，初始条件为：
\[ dp[0] = 1 \]
\[ dp[1] = 1 \]

##### 4. 计算顺序

从 `i=2` 开始，逐步计算到 `n` 阶的方法数：
\[ dp[2], dp[3], \ldots, dp[n] \]

##### 5. 优化空间复杂度（可选）

由于每次计算 `dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，我们可以使用滚动数组来优化空间复杂度。

#### 代码实现

##### 标准动态规划（自下而上）

```
public int climbStairs(int n) {
    if (n <= 1) {
        return 1;
    }
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
##### 优化空间复杂度的动态规划（滚动数组）
~~~
public int climbStairsOptimized(int n) {
    if (n <= 1) {
        return 1;
    }
    int prev1 = 1, prev2 = 1;
    for (int i = 2; i <= n; i++) {
        int current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    return prev1;
}
~~~

### 动态规划解题步骤总结
1. 定义子问题：明确子问题的含义以及如何表示状态。 
2. 推导状态转移方程：找出如何通过已解决的子问题来解决当前子问题。 
3. 确定初始条件和边界条件：明确最基本子问题的解和边界条件。 
4. 计算顺序：决定计算子问题的顺序，从最小子问题开始逐步解决。 
5. 优化空间复杂度（可选）：根据问题的特性，考虑是否可以优化空间使用。
通过这五个步骤，可以系统地解决大多数动态规划问题，确保代码的正确性和效率。

931. 下降路径最小和 minFallingPathSum
221. 最大正方形
5. 最长回文子串 
516. 最长回文子序列
72. 编辑距离
312. 戳气球
712. 两个字符串的最小ASCII删除和
115. 不同的子序列 困难
300. 最长递增子序列
673. 最长递增子序列的个数
646. 最长数对链
55. 跳跃游戏
